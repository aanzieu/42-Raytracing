#include <cuda.h>
#include <stdio.h>
#include <float.h>
extern "C" {
	#include "../../../includes/display.h"
	#include "../../../includes/vectors.h"
	#include "../../../includes/rtv1.h"			
}
#include "../cudaheader/gpu_rtv1.cuh"

#define CUDA_ERROR_CHECK

#define CudaSafeCall( err ) __cudaSafeCall( err, __FILE__, __LINE__ )

#define CudaCheckError()    __cudaCheckError( __FILE__, __LINE__ )

inline void __cudaSafeCall( cudaError err, const char *file, const int line )
{
#ifdef CUDA_ERROR_CHECK
    if ( cudaSuccess != err )
    {
        fprintf( stderr, "cudaSafeCall() failed at %s:%i : %s\n",
                 file, line, cudaGetErrorString( err ) );
        exit( -1 );
    }
#endif

    return;
}

inline void __cudaCheckError( const char *file, const int line )
{
#ifdef CUDA_ERROR_CHECK
    cudaError err = cudaGetLastError();
    if ( cudaSuccess != err )
    {
        fprintf( stderr, "cudaCheckError() failed at %s:%i : %s\n",
                 file, line, cudaGetErrorString( err ) );
        exit( -1 );
    }

    // // More careful checking. However, this will affect performance.
    // // Comment away if needed.
    // err = cudaDeviceSynchronize();
    // if( cudaSuccess != err )
    // {
    //     fprintf( stderr, "cudaCheckError() with sync failed at %s:%i : %s\n",
    //              file, line, cudaGetErrorString( err ) );
    // //     exit( -1 );
    // }
#endif

    return;
}

__global__ void test(int *a, unsigned int constw, unsigned int consth, t_world world)
{	
	int col = blockIdx.x * blockDim.x + threadIdx.x;
	int row = blockIdx.y * blockDim.y + threadIdx.y;
	int index = row * constw + col;
	a[index] = ray_tracer(world, col, row);
	// a[index] = RED;
	//printf(1, "re\n");
// if (row == 0 || col == 0)
// 	 a[index] = RED;
// else
 	// a[index] = RED;

}

extern "C" void render_cuda(int *a_h, unsigned int constw, unsigned int consth, t_world world, int reset)
{
	int				i;
	int 			j;
	static int 		*a_d;
	t_sphere		*spheres_d;
	// t_plane			*planes_d;
	// t_cone			*cones_d;
	// t_cylinder		*cylinders_d;
	static size_t	size = 0;
	static dim3		threads_per_block(16, 16);
	static dim3		grid_size(constw / threads_per_block.x, consth / threads_per_block.y);

	if (reset == 0)
	{
		if (size == 0)
		{
			size = constw * consth * sizeof(int);
			CudaSafeCall(cudaMalloc(&a_d, size));
		}
		CudaSafeCall(cudaMalloc(&spheres_d, sizeof(t_sphere) * 1));
		CudaSafeCall(cudaMemcpy(spheres_d, world.spheres, sizeof(t_sphere) * 1, cudaMemcpyHostToDevice));
		world.spheres = spheres_d;
		// CudaSafeCall(cudaMalloc(&planes_d, sizeof(t_plane) * world.planes_len));
		// CudaSafeCall(cudaMemcpy(planes_d, world.planes, sizeof(t_plane) * world.planes_len, cudaMemcpyHostToDevice));
		// world.planes = planes_d;
		test <<< grid_size, threads_per_block>>> (a_d, constw, consth, world);
		CudaCheckError();
		CudaSafeCall(cudaMemcpy(a_h, a_d, size, cudaMemcpyDeviceToHost));
		i = 0;
		while (i < consth)
		{
			j = 0;
			while (j < constw)
			{
				pixel_to_image(world.window.screen, j, i, a_h[i * constw + j]);
				// printf("a[%d][%d] = %f\n", i, j, a_h[i * constw + j]);
				j++;	
			}
			i++;
		}
		cudaFree(spheres_d);
		// cudaFree(planes_d);		
	}
	else
		cudaFree(a_d);
}
